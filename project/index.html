<!DOCTYPE html>
<meta charset="utf-8">
<style> /* set the CSS */

body { font: 12px Arial;}

</style>
<script src="https://d3js.org/d3.v7.min.js"></script>


<body>
</body>
<script>

 

    d3.csv("prototype.csv").then(function (x) {
           // Set the dimensions of the canvas / graph
var margin = {top: 30, right: 20, bottom: 30, left: 50},
    width = 600 - margin.left - margin.right,
    height = 270 - margin.top - margin.bottom;

// Parse the date / time
//var parseDate = d3.time.format("%d-%b-%y").parse;

// Set the ranges
var x1 = d3.scaleLinear().range([0, width]);
var y1 = d3.scaleLinear().range([height, 0]);

// Define the line
/*var valueline = d3.line()
    .x(function(d) { return x1(x.indexOf(d)); })
    .y(function(d) { return y1(d.SucRate); });*/

//overall svg
let svg = d3.select("body")
            .append("svg")
            .attr("width", 1400)
            .attr("height", 1000)
            .attr("id","mainsvg");



    
// Adds the svg canvas
var svg2 = d3.select("svg#mainsvg")
    .append("svg")
    .append("g")
    .attr("id","pointplot")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("transform", 
              "translate(" + 750 + "," + margin.top + ")")
              .attr("html", "true");



              var svg3 = d3.select("svg#mainsvg")
        .append("g") //group to move svgsideways
        .append("svg")
        .attr("id","spiderchart");



         //convert strings into numbers
         x.forEach(function (d) {
            d.Deviations = +d.Deviations;
            d.EmotionCount = +d.EmotionCount;
            d.NumberWord = +d.NumberWord;
            d.SucRate = +d.SucRate;
            d.Time2ans = +d.Time2ans;

        });


        // Scale the range of the data
    x1.domain(d3.extent(x, function(d) { return x.indexOf(d); }));
    y1.domain([0, d3.max(x, function(d) { return d.SucRate; })]);


    // Add the scatterplot
    svg2.selectAll("dot")
        .data(x)
      .enter().append("circle")
        .attr("r", 3.5)
        .attr("cx", function(d) { return x1(x.indexOf(d)); })
        .attr("cy", function(d) { return y1(d.SucRate); });

   // Add the X Axis
  svg2.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x1));

  // Add the Y Axis
  svg2.append("g")
      .call(d3.axisLeft(y1));


        //array that holds the normalized dataset
        var data = [];

        //array that holds the actual values
        var temp = [];

        var temp2 =[];

        //columns names
        let features = [];

        var length = x.length
        console.log(length)

    
        var max = {
            Deviations: d3.max(x, d => d.Deviations),
            EmotionCount: d3.max(x, d => d.EmotionCount),
            NumberWord: d3.max(x, d => d.NumberWord),
            SucRate: d3.max(x, d => d.SucRate),
            Time2ans: d3.max(x, d => d.Time2ans)
        }

        var min = {
            Deviations: d3.min(x, d => d.Deviations),
            EmotionCount: d3.min(x, d => d.EmotionCount),
            NumberWord: d3.min(x, d => d.NumberWord),
            SucRate: d3.min(x, d => d.SucRate),
            Time2ans: d3.min(x, d => d.Time2ans)
        }

        console.log(min)
        console.log(max)

        /*x.forEach(function(d){
            d.Deviations = (d.Deviations - min.Deviations)/(max.Deviations - min.Deviations)
            d.EmotionCount = (d.EmotionCount - min.EmotionCount)/(max.EmotionCount - min.EmotionCount)
            d.NumberWord = (d.NumberWord - min.NumberWord)/(max.NumberWord - min.NumberWord)
            d.Time2ans = (d.Time2ans - min.Time2ans)/(max.Time2ans - min.Time2ans)
            d.SucRate = (d.SucRate - min.SucRate)/(max.SucRate - min.SucRate)
            temp2.push(d);
        });*/
        

        //compute average
        var average = {
            Deviations: d3.mean(x, d => d.Deviations).toFixed(5),
            EmotionCount: d3.mean(x, d => d.EmotionCount).toFixed(5),
            NumberWord: d3.mean(x, d => d.NumberWord).toFixed(5),
            SucRate: d3.mean(x, d => d.SucRate).toFixed(5),
            Time2ans: d3.mean(x, d => d.Time2ans).toFixed(5)
        }
        temp.push(average)
        console.log(temp)

        //min_max normalization
        for(var i = 0; i< length;++i){
            var d = JSON.parse(JSON.stringify(x[i]))
            d.Deviations = (d.Deviations - min.Deviations)/(max.Deviations - min.Deviations)
            d.EmotionCount = (d.EmotionCount - min.EmotionCount)/(max.EmotionCount - min.EmotionCount)
            d.NumberWord = (d.NumberWord - min.NumberWord)/(max.NumberWord - min.NumberWord)
            d.Time2ans = (d.Time2ans - min.Time2ans)/(max.Time2ans - min.Time2ans)
            d.SucRate = (d.SucRate - min.SucRate)/(max.SucRate - min.SucRate)
            temp2.push(d)
        }
        //console.log(temp2)

        var averageNorm = {
            Deviations: d3.mean(temp2,d => d.Deviations),
            EmotionCount: d3.mean(temp2,d => d.EmotionCount),
            NumberWord: d3.mean(temp2, d => d.NumberWord),
            SucRate: d3.mean(temp2, d => d.SucRate),
            Time2ans: d3.mean(temp2, d => d.Time2ans)
        }
        temp2.unshift(averageNorm)
        data.push(averageNorm);

        console.log(data)


        for(var i = 1;i < data.length;++i){
            var reverse = JSON.parse(JSON.stringify(data[i]));
            reverse.Deviations = reverse.Deviations*(max.Deviations - min.Deviations)+min.Deviations
            reverse.NumberWord = reverse.NumberWord*(max.NumberWord - min.NumberWord)+min.NumberWord
            reverse.EmotionCount = reverse.EmotionCount*(max.EmotionCount - min.EmotionCount)+min.EmotionCount
            reverse.SucRate = reverse.SucRate*(max.SucRate - min.SucRate)+min.SucRate
            reverse.Time2ans = reverse.Time2ans*(max.Time2ans - min.Time2ans)+min.Time2ans
            temp.push(reverse)
        }
        console.log(temp)

        features = Object.keys(data[0])


        //convert the scale from [0,1] to pixels
        let radialScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, 250]);

        let ticks = [0.2, 0.4, 0.6, 0.8, 1];

        //circles for the radar
        ticks.forEach(t =>
            svg3.append("circle")
                .attr("cx", 350)
                .attr("cy", 350)
                .attr("fill", "none")
                .attr("stroke", "gray")
                .attr("r", radialScale(t))
        );

        //labels
        ticks.forEach(t =>
            svg3.append("text")
                .attr("x", 355)
                .attr("y", 350 - radialScale(t))
                .text(t.toString())
        );

        function angleToCoordinate(angle, value) {
            let x = Math.cos(angle) * radialScale(value);
            let y = Math.sin(angle) * radialScale(value);
            return { "x": 350 + x, "y": 350 - y };
        }


        //draw text and label
        for (var i = 0; i < features.length; i++) {
            let ft_name = features[i];
            let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
            var line_coordinate = 0;
            var label_coordinate = 0;
            if (features[i] === "EmotionCount") {
                line_coordinate = angleToCoordinate(angle, 1);
                label_coordinate = angleToCoordinate(angle, 1.35);
            } else {
                if (features[i] === "NumberWord") {
                    line_coordinate = angleToCoordinate(angle, 1);
                    label_coordinate = angleToCoordinate(angle, 1.2);
                } else {
                    line_coordinate = angleToCoordinate(angle, 1);
                    label_coordinate = angleToCoordinate(angle, 1.05);
                }
            }

            //draw axis line
            svg3.append("line")
                .attr("x1", 350)
                .attr("y1", 350)
                .attr("x2", line_coordinate.x)
                .attr("y2", line_coordinate.y)
                .attr("stroke", "black");

            //draw axis label
            svg3.append("text")
                .attr("x", label_coordinate.x)
                .attr("y", label_coordinate.y)
                .text(ft_name);
        }


        let line = d3.line()
            .x(d => d.x)
            .y(d => d.y);

        
        let colors = ["darkorange", "gray", "navy"];


        function getPathCoordinates(data_point) {
            let coordinates = [];
            for (var i = 0; i < features.length; i++) {
                let ft_name = features[i];
                let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
                coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
            }
            return coordinates;
        }

        //options to the button
       /* d3.select("#selectButton")
            .selectAll('myOptions')
            .data(temp2)
            .enter()
            .append('option')
            .text(function(d) { var i = temp2.indexOf(d);
                return `interaction ${i+1}`})
            .attr("value",function(d){ return getPathCoordinates(d);})
            .attr("x",0)
            .attr("y",0)*/

        

        var g = svg3.append("g")
            .attr("transform", "translate(" + 100 + "," + 100 + ")")
            .attr("html", "true");
            
        let tooltips1 = [];

        for (var i = 0; i < features.length; i++) {
            var tooltip = g.append("text")
                .attr("class", "tooltip")
                .style("opacity", 0);

            tooltips1.push(tooltip);
        }

        for (var i = 0; i < data.length; i++) {

            let d = data[i];
            let d2 = temp[i];
            let color = colors[i];
            let coordinates = getPathCoordinates(d);

            //draw the path element
            svg3.append("path")
                .datum(coordinates)
                .attr("d", line)
                .attr("stroke-width", 3)
                .attr("stroke", color)
                .attr("fill", color)
                .attr("stroke-opacity", 1)
                .attr("opacity", 0.5)
                .on('mouseover', function (da, i) {
                    //Dim all blobs
                    d3.selectAll(".radarArea")
                        .transition().duration(200)
                        .style("opacity", 0.5);
                    //Bring back the hovered over blob
                    d3.select(this)
                        .transition().duration(200)
                        .style("opacity", 0.8);
                    da = d2;
                    console.log(da)
                    for (var i = 0; i < features.length; i++) {
                        tooltips1[i]
                            .attr('x', 440)
                            .attr('y', 1 + (i * 18))
                            .text(features[i] + " : " + Object.values(da)[i])
                            .transition().duration(200)
                            .style('opacity', 1);
                    }
                    //console.log(da.length);
                    //console.log(da);

                })
                .on('mouseout', function () {
                    //Bring back all blobs
                    d3.selectAll(".radarArea")
                        .transition().duration(200)
                        .style("opacity", 0.35);
                    d3.select(this)
                        .transition().duration(200)
                        .style("opacity", 0.35);
                    for (var i = 0; i < features.length; i++) {
                        tooltips1[i].transition().duration(200)
                            .style("opacity", 0);
                    }

                });
        }  

    });



</script>

</html>